<?xml version="1.0" encoding="UTF-8"?>
<module xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="http://www.chibios.org/xml/schema/ccode/modules.xsd"
  name="hal_snor_base" descr="SNOR Base Driver" editcode="false">
  <brief>SNOR abstract driver.</brief>
  <details><![CDATA[Base class for SNOR flash devices.]]></details>
  <imports>
    <import>oop_base_object.xml</import>
    <import>hal_flash_interface.xml</import>
  </imports>
  <public>
    <includes>
      <include style="regular">oop_base_object.h</include>
      <include style="regular">oop_base_interface.h</include>
      <include style="regular">hal_flash_interface.h</include>
    </includes>
    <definitions_early>
    </definitions_early>
    <configs>
      <config name="SNOR_BUFFER_SIZE" default="32">
        <brief>Non-cacheable operations buffer.</brief></config>
    </configs>
    <macros></macros>
    <types>
      <typedef name="snor_buffers_t">
        <brief>Type of a non-cacheable buffer.</brief>
        <basetype ctype="struct snor_buffers" />
      </typedef>
      <typedef name="snor_config_t">
        <brief>Type of a SNOR configuration structure.</brief>
        <basetype ctype="struct snor_config" />
      </typedef>
      <struct name="snor_buffers">
        <brief>SNOR driver configuration.</brief>
        <fields>
          <field name="cmdbuf" ctype="wspi_command_t">
            <brief>Non-cacheable WSPI command buffer.</brief>
          </field>
          <field name="databuf" ctype="uint8_t$I$N[SNOR_BUFFER_SIZE]">
            <brief>Non-cacheable data buffer.</brief>
          </field>
        </fields>
      </struct>
      <struct name="snor_config">
        <brief>SNOR driver configuration.</brief>
        <fields>
          <field name="wspi" ctype="WSPIDriver$I*$N">
            <brief>WSPI driver to be used for physical communication.</brief>
          </field>
          <field name="wspicfg" ctype="const WSPIConfig$I*$N">
            <brief>WSPI driver configuration.</brief>
          </field>
          <field name="buffers" ctype="struct snor_buffers_t$I*$N">
            <brief>Pointer to the non-cacheable buffers.</brief>
          </field>
        </fields>
      </struct>
      <class name="hal_snor_base" type="abstract" namespace="snorbase"
        descr="SNOR base driver" ancestorname="base_object">
        <brief>Base class of all SNOR drivers.</brief>
        <implements>
          <if name="flash_interface">
            <method shortname="get_descriptor">
              <implementation><![CDATA[

return snor_device_get_descriptor(self);]]></implementation>
            </method>
            <method shortname="read">
              <implementation><![CDATA[
flash_error_t err;

osalDbgCheck((self != NULL) && (rp != NULL) && (n > 0U));
osalDbgAssert((self->state == FLASH_READY) || (self->state == FLASH_ERASE),
              "invalid state");

if (self->state == FLASH_ERASE) {
  return FLASH_BUSY_ERASING;
}

/* Bus acquired.*/
wspiAcquireBus(self->config->wspi);

/* FLASH_READY state while the operation is performed.*/
self->state = FLASH_READ;

/* Actual read implementation.*/
err = snor_device_read(self, offset, n, rp);

/* Ready state again.*/
self->state = FLASH_READY;

/* Bus released.*/
wspiReleaseBus(self->config->wspi);

return err;]]></implementation>
            </method>
            <method shortname="program">
              <implementation><![CDATA[
flash_error_t err;

osalDbgCheck((self != NULL) && (pp != NULL) && (n > 0U));
osalDbgAssert((self->state == FLASH_READY) || (self->state == FLASH_ERASE),
              "invalid state");

if (self->state == FLASH_ERASE) {
  return FLASH_BUSY_ERASING;
}

/* Bus acquired.*/
wspiAcquireBus(self->config->wspi);

/* FLASH_PGM state while the operation is performed.*/
self->state = FLASH_PGM;

/* Actual program implementation.*/
err = snor_device_program(self, offset, n, pp);

/* Ready state again.*/
self->state = FLASH_READY;

/* Bus released.*/
wspiReleaseBus(self->config->wspi);

return err;]]></implementation>
            </method>
            <method shortname="start_erase_all">
              <implementation><![CDATA[
flash_error_t err;

osalDbgCheck(self != NULL);
osalDbgAssert((self->state == FLASH_READY) || (self->state == FLASH_ERASE),
              "invalid state");

if (self->state == FLASH_ERASE) {
  return FLASH_BUSY_ERASING;
}

/* Bus acquired.*/
wspiAcquireBus(self->config->wspi);

/* FLASH_ERASE state while the operation is performed.*/
self->state = FLASH_ERASE;

/* Actual erase implementation.*/
err = snor_device_start_erase_all(self);

/* Bus released.*/
wspiReleaseBus(self->config->wspi);

return err;]]></implementation>
            </method>
            <method shortname="start_erase_sector">
              <implementation><![CDATA[
flash_error_t err;

osalDbgCheck(self != NULL);
osalDbgAssert((self->state == FLASH_READY) || (self->state == FLASH_ERASE),
              "invalid state");

if (self->state == FLASH_ERASE) {
  return FLASH_BUSY_ERASING;
}

/* Bus acquired.*/
wspiAcquireBus(self->config->wspi);

/* FLASH_ERASE state while the operation is performed.*/
self->state = FLASH_ERASE;

/* Actual erase implementation.*/
err = snor_device_start_erase_sector(self, sector);

/* Bus released.*/
wspiReleaseBus(self->config->wspi);

return err;]]></implementation>
            </method>
            <method shortname="query_erase">
              <implementation><![CDATA[
flash_error_t err;

osalDbgCheck(self != NULL);
osalDbgAssert((self->state == FLASH_READY) || (self->state == FLASH_ERASE),
              "invalid state");

/* If there is an erase in progress then the device must be checked.*/
if (self->state == FLASH_ERASE) {

  /* Bus acquired.*/
  wspiAcquireBus(self->config->wspi);

  /* Actual query erase implementation.*/
  err = snor_device_query_erase(self, msec);

  /* The device is ready to accept commands.*/
  if (err == FLASH_NO_ERROR) {
    self->state = FLASH_READY;
  }

  /* Bus released.*/
  wspiReleaseBus(self->config->wspi);
}
else {
  err = FLASH_NO_ERROR;
}

return err;]]></implementation>
            </method>
            <method shortname="verify_erase">
              <implementation><![CDATA[
flash_error_t err;

osalDbgCheck(self != NULL);
osalDbgAssert((self->state == FLASH_READY) || (self->state == FLASH_ERASE),
              "invalid state");

if (self->state == FLASH_ERASE) {
  return FLASH_BUSY_ERASING;
}

/* Bus acquired.*/
wspiAcquireBus(self->config->wspi);

/* FLASH_READY state while the operation is performed.*/
self->state = FLASH_READ;

/* Actual verify erase implementation.*/
err = snor_device_verify_erase(self, sector);

/* Ready state again.*/
self->state = FLASH_READY;

/* Bus released.*/
wspiReleaseBus(self->config->wspi);

return err;]]></implementation>
            </method>
            <method shortname="acquire_exclusive">
              <implementation><![CDATA[

osalMutexLock(&self->mutex);
return FLASH_NO_ERROR;
]]></implementation>
            </method>
            <method shortname="release_exclusive">
              <implementation><![CDATA[

osalMutexUnlock(&self->mutex);
return FLASH_NO_ERROR;
]]></implementation>
            </method>
          </if></implements>
        <fields>
          <field name="state" ctype="flash_state_t">
            <brief>Driver state.</brief></field>
          <field name="config" ctype="const snor_config_t$I*$N">
            <brief>Driver configuration.</brief></field>
          <field name="mutex" ctype="mutex_t">
            <brief>Flash access mutex.</brief></field>
        </fields>
        <methods>
          <objinit callsuper="true">
            <implementation><![CDATA[
self->state = FLASH_UNINIT;
self->config = NULL;
osalMutexObjectInit(&self->mutex);]]></implementation>
          </objinit>
          <dispose>
            <implementation><![CDATA[;]]></implementation>
          </dispose>
          <virtual>
            <method shortname="init" name="snor_device_init" ctype="flash_error_t">
              <return>An error code.</return>
              <retval value="FLASH_NO_ERROR">Initialization successful.</retval>
              <retval value="FLASH_ERROR_HW_FAILURE">Initialization failed.</retval>
              <notapi />
            </method>
            <method shortname="get_descriptor" name="snor_device_get_descriptor" ctype="const flash_descriptor_t *">
              <notapi />
            </method>
            <method shortname="read" name="snor_device_read" ctype="flash_error_t">
              <brief>Read operation.</brief>
              <param name="offset" ctype="flash_offset_t" dir="in">flash offset</param>
              <param name="n" ctype="size_t" dir="in">number of bytes to be read</param>
              <param name="rp" ctype="uint8_t *" dir="out">pointer to the data buffer</param>
              <return>An error code.</return>
              <retval value="FLASH_NO_ERROR">Operation successful.</retval>
              <retval value="FLASH_ERROR_READ">If the read operation failed.</retval>
              <retval value="FLASH_ERROR_HW_FAILURE">If access to the memory failed.</retval>
              <notapi />
            </method>
            <method shortname="program" name="snor_device_program" ctype="flash_error_t">
              <brief>Program operation.</brief>
              <param name="offset" ctype="flash_offset_t" dir="in">flash offset</param>
              <param name="n" ctype="size_t" dir="in">number of bytes to be programmed</param>
              <param name="pp" ctype="const uint8_t *" dir="in">pointer to the data buffer</param>
              <return>An error code.</return>
              <retval value="FLASH_NO_ERROR">Operation successful.</retval>
              <retval value="FLASH_ERROR_PROGRAM">If the program operation failed.</retval>
              <retval value="FLASH_ERROR_HW_FAILURE">If access to the memory failed.</retval>
              <notapi />
            </method>
            <method shortname="start_erase_all" name="snor_device_start_erase_all" ctype="flash_error_t">
              <brief>Starts a whole-device erase operation.</brief>
              <return>An error code.</return>
              <retval value="FLASH_NO_ERROR">Operation successful.</retval>
              <retval value="FLASH_ERROR_HW_FAILURE">If access to the memory failed.</retval>
              <notapi />
            </method>
            <method shortname="start_erase_sector" name="snor_device_start_erase_sector" ctype="flash_error_t">
              <brief>Starts an sector erase operation.</brief>
              <param name="sector" ctype="const flash_sector_t *" dir="in">sector to be erased</param>
              <return>An error code.</return>
              <retval value="FLASH_NO_ERROR">Operation successful.</retval>
              <retval value="FLASH_ERROR_HW_FAILURE">If access to the memory failed.</retval>
              <notapi />
            </method>
            <method shortname="query_erase" name="snor_device_query_erase" ctype="flash_error_t">
              <brief>Queries the driver for erase operation progress.</brief>
              <param name="msec" ctype="unsigned *" dir="out">recommended time, in milliseconds,
               that should be spent before calling this function again, can be @p NULL</param>
              <return>An error code.</return>
              <retval value="FLASH_NO_ERROR">If there is no erase operation in progress.</retval>
              <retval value="FLASH_ERROR_HW_FAILURE">If access to the memory failed.</retval>
              <notapi />
            </method>
            <method shortname="verify_erase" name="snor_device_verify_erase" ctype="flash_error_t">
              <brief>Returns the erase state of a sector.</brief>
              <param name="sector" ctype="const flash_sector_t *" dir="in">sector to be verified</param>
              <return>An error code.</return>
              <retval value="FLASH_NO_ERROR">Operation successful.</retval>
              <retval value="FLASH_ERROR_VERIFY">If the verify operation failed.</retval>
              <retval value="FLASH_ERROR_HW_FAILURE">If access to the memory failed.</retval>
              <notapi />
            </method>
            <method shortname="mmap_on" name="snor_device_mmap_on" ctype="flash_error_t">
              <param name="addrp" ctype="uint8_t **" dir="out">pointer to the
               memory mapped memory or @p NULL</param>
              <return>An error code.</return>
              <retval value="FLASH_NO_ERROR">Memory map mode successful.</retval>
              <retval value="FLASH_ERROR_HW_FAILURE">Memory map mode failed.</retval>
              <notapi />
            </method>
            <method shortname="mmap_off" name="snor_device_mmap_off" ctype="void">
              <notapi />
            </method>
          </virtual>
          <regular>
            <method name="xsnorStart" ctype="flash_error_t">
              <brief>Configures and activates a SNOR driver.</brief>
              <param name="config" ctype="const snor_config_t *" dir="in">pointer to the configuration</param>
              <return>An error code.</return>
              <retval value="FLASH_NO_ERROR">Operation successful.</retval>
              <retval value="FLASH_ERROR_HW_FAILURE">If initialization failed.</retval>
              <api />
              <implementation><![CDATA[
flash_error_t err;

osalDbgCheck((self != NULL) && (config != NULL));
osalDbgAssert(self->state != FLASH_UNINIT, "invalid state");

self->config = config;

if (self->state == FLASH_STOP) {

  /* Bus acquisition.*/
  wspiAcquireBus(self->config->wspi);

  wspiStart(self->config->wspi, self->config->wspicfg);

  /* Device identification and initialization.*/
  err = snor_device_init(self);
  if (err == FLASH_NO_ERROR) {
    /* Driver in ready state.*/
    self->state = FLASH_READY;
  }

  /* Bus release.*/
  wspiReleaseBus(self->config->wspi);
}

return err;]]></implementation>
            </method>
            <method name="xsnorStop" ctype="void">
              <brief>Deactivates a SNOR driver.</brief>
              <api />
              <implementation><![CDATA[
osalDbgCheck(self != NULL);
osalDbgAssert(self->state != FLASH_UNINIT, "invalid state");

if (self->state != FLASH_STOP) {

  /* Stopping bus device.*/
  wspiStop(self->config->wspi);

  /* Driver stopped.*/
  self->state = FLASH_STOP;

  /* Deleting current configuration.*/
  self->config = NULL;
}]]></implementation>
            </method>
            <condition check="WSPI_SUPPORTS_MEMMAP == TRUE">
              <method name="xsnorMemoryMap" ctype="flash_error_t">
                <brief>Enters the memory mapped mode.</brief>
                <param name="addrp" ctype="uint8_t **" dir="out">pointer to the
                 memory mapped memory or @p NULL</param>
                <return>An error code.</return>
                <retval value="FLASH_NO_ERROR">Operation successful.</retval>
                <retval value="FLASH_ERROR_HW_FAILURE">If memory mapped mode failed.</retval>
                <api />
                <implementation>
flash_error_t err;

/* Activating XIP mode in the device.*/
err = snor_device_mmap_on(self, addrp);

return err;</implementation>
              </method>
              <method name="xsnorMemoryUnmap" ctype="void">
                <brief>Leaves the memory mapped mode.</brief>
                <api />
                <implementation>

snor_device_mmap_off(self);</implementation>
              </method>
            </condition>
          </regular>
        </methods>
      </class>
    </types>
    <variables></variables>
    <functions></functions>
  </public>
  <private>
    <includes>
      <include style="regular">hal.h</include>
      <include style="regular">hal_snor_base.h</include>
    </includes>
    <functions></functions>
  </private>
</module>
