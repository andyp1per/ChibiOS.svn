<?xml version="1.0" encoding="UTF-8"?>
<module xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="http://www.chibios.org/xml/schema/ccode/modules.xsd"
  name="hal_spi" descr="SPI Driver" check="HAL_USE_SPI == TRUE" editcode="false">
  <brief>SPI Driver macros and structures.</brief>
  <imports>
    <import>hal_cb_driver.xml</import>
  </imports>
  <public>
    <definitions_early>
      <group description="SPI CS modes">
        <define name="SPI_SELECT_MODE_NONE" value="0">
          <brief>@p spiSelect() and @p spiUnselect() do nothing.</brief>
        </define>
        <define name="SPI_SELECT_MODE_PAD" value="1">
          <brief>Selection by PAL port and pad number.</brief>
        </define>
        <define name="SPI_SELECT_MODE_PORT" value="2">
          <brief>Selection by port and port mask.</brief>
        </define>
        <define name="SPI_SELECT_MODE_LINE" value="3">
          <brief>Selection by PAL line identifier.</brief>
        </define>
        <define name="SPI_SELECT_MODE_LLD" value="4">
          <brief>Selection by LLD-defined mode.</brief>
        </define>
      </group>
    </definitions_early>
    <configs>
      <config name="SPI_USE_SYNCHRONIZATION" default="TRUE">
        <brief>Support for thread synchronization API.</brief>
        <assert invalid="($N != FALSE) &amp;&amp; ($N != TRUE)" />
      </config>
      <config name="SPI_SELECT_MODE" default="SPI_SELECT_MODE_PAD">
        <brief>Handling method for SPI CS line.</brief>
        <assert
          invalid="($N &lt; SPI_SELECT_MODE_NONE) || ($N &gt; SPI_SELECT_MODE_LLD)" />
      </config>
    </configs>
    <types>
      <typedef name="hal_spi_config_t">
        <brief>Type of structure representing a SPI configuration.</brief>
        <basetype ctype="struct hal_spi_config" />
      </typedef>
      <typedef name="SPIConfig">
        <brief>Type of structure representing a SPI configuration
          (legacy).</brief>
        <basetype ctype="struct hal_spi_config" />
      </typedef>
      <typedef name="SPIDriver">
        <brief>Type of structure representing a SPI driver (legacy).</brief>
        <basetype ctype="struct hal_spi_driver" />
      </typedef>
      <verbatim><![CDATA[
/* Inclusion of LLD header.*/
#include "hal_spi_lld.h"

#if !defined(SPI_SUPPORTS_CIRCULAR)
#error "SPI_SUPPORTS_CIRCULAR not defined in SPI LLD driver"
#endif

#if !defined(SPI_SUPPORTS_SLAVE_MODE)
#error "SPI_SUPPORTS_SLAVE_MODE not defined in SPI LLD driver"
#endif]]></verbatim>
      <struct name="hal_spi_config">
        <brief>Driver configuration structure.</brief>
        <note>Implementations may extend this structure to contain more,
          architecture dependent, fields.
        </note>
        <fields>
          <condition check="SPI_SUPPORTS_CIRCULAR == TRUE">
            <field name="circular" ctype="bool">
              <brief>Enables the circular buffer mode.</brief>
            </field>
          </condition>
          <condition check="SPI_SUPPORTS_SLAVE_MODE == TRUE">
            <field name="slave" ctype="bool">
              <brief>Enables the slave mode.</brief>
            </field>
          </condition>
          <condition check="SPI_SELECT_MODE == SPI_SELECT_MODE_LINE">
            <field name="ssline" ctype="ioline_t">
              <brief>The chip select line.</brief>
              <note>Only used in master mode.</note>
            </field>
          </condition>
          <condition check="SPI_SELECT_MODE == SPI_SELECT_MODE_PORT">
            <field name="ssport" ctype="ioportid_t">
              <brief>The chip select port.</brief>
              <note>Only used in master mode.</note>
            </field>
            <field name="ssmask" ctype="ioportmask_t">
              <brief>The chip select port mask.</brief>
              <note>Only used in master mode.</note>
            </field>
          </condition>
          <condition check="SPI_SELECT_MODE == SPI_SELECT_MODE_PAD">
            <field name="ssport" ctype="ioportid_t">
              <brief>The chip select port.</brief>
              <note>Only used in master mode.</note>
            </field>
            <field name="sspad" ctype="ioportmask_t">
              <brief>The chip select pad number.</brief>
              <note>Only used in master mode.</note>
            </field>
          </condition>
          <verbatim><![CDATA[
/* End of the mandatory fields.*/
spi_lld_config_fields;]]></verbatim>
          <condition check="defined(SPI_CONFIG_EXT_FIELS)">
            <verbatim><![CDATA[
SPI_CONFIG_EXT_FIELDS]]></verbatim>
          </condition>
        </fields>
      </struct>
      <class type="regular" name="hal_spi_driver" namespace="spi"
        ancestorname="hal_cb_driver" descr="SPI driver">
        <brief>Class of a SPI driver.</brief>
        <fields>
          <verbatim><![CDATA[
#if defined(SPI_DRIVER_EXT_FIELS)
SPI_DRIVER_EXT_FIELDS
#endif
/* End of the mandatory fields.*/
spi_lld_driver_fields;]]></verbatim>
        </fields>
        <methods>
          <objinit callsuper="true">
            <implementation><![CDATA[

/* Optional, user-defined initializer.*/
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
SPI_DRIVER_EXT_INIT_HOOK(self);
#endif]]></implementation>
          </objinit>
          <dispose>
            <implementation><![CDATA[ ]]></implementation>
          </dispose>
          <inline>
            <condition check="SPI_SELECT_MODE == SPI_SELECT_MODE_LLD">
              <method name="spiSelectX" ctype="void">
                <brief>Asserts the slave select signal and prepares for
                  transfers.</brief>
                <xclass />
                <implementation><![CDATA[

spi_lld_select(self);]]></implementation>
              </method>
              <method name="spiUnselectX" ctype="void">
                <brief>Deasserts the slave select signal.</brief>
                <xclass />
                <implementation><![CDATA[

spi_lld_unselect(self);]]></implementation>
              </method>
              <elseif check="SPI_SELECT_MODE == SPI_SELECT_MODE_LINE" />
              <method name="spiSelectX" ctype="void">
                <implementation><![CDATA[

palClearLine(self->config->ssline);]]></implementation>
              </method>
              <method name="spiUnselectX" ctype="void">
                <implementation><![CDATA[

palSetLine(self->config->ssline);]]></implementation>
              </method>
              <elseif check="SPI_SELECT_MODE == SPI_SELECT_MODE_PORT" />
              <method name="spiSelectX" ctype="void">
                <implementation><![CDATA[

palClearPort(self->config->ssport, (spip)->config->ssmask);]]></implementation>
              </method>
              <method name="spiUnselectX" ctype="void">
                <implementation><![CDATA[

palSetPort(self->config->ssport, (spip)->config->ssmask);]]></implementation>
              </method>
              <elseif check="SPI_SELECT_MODE == SPI_SELECT_MODE_PAD" />
              <method name="spiSelectX" ctype="void">
                <implementation><![CDATA[

palClearPad(self->config->ssport, (spip)->config->sspad);]]></implementation>
              </method>
              <method name="spiUnselectX" ctype="void">
                <implementation><![CDATA[

palSetPad(self->config->ssport, (spip)->config->sspad);]]></implementation>
              </method>
            </condition>
          </inline>
        </methods>
      </class>
    </types>
    <functions>
      <function name="spiInit" ctype="void">
        <brief>SPI Driver initialization.</brief>
        <note>
          This function is implicitly invoked by @p halInit(), there is no
          need to explicitly initialize the driver.
        </note>
        <init />
        <implementation><![CDATA[

spi_lld_init();]]></implementation>
      </function>
    </functions>
  </public>
  <private>
    <includes_always>
      <include style="regular">hal.h</include>
    </includes_always>
  </private>
</module>